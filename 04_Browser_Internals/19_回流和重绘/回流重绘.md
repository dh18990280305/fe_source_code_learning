### 一、概念（从渲染流水线视角）

| 概念 | 核心定义 | 对应渲染阶段 | 性能消耗 |
| ----------- | ----------- | ----------- | ----------- |
| 回流（Reflow） | 当元素的几何属性（位置、尺寸、盒模型）变化时，浏览器重新计算布局树的过程 | 布局（Layout） | 极高 |
| 重绘（Repaint） | 当元素的视觉属性（颜色、背景、阴影）变化但几何属性不变时，浏览器重新绘制像素的过程 | 绘制（Paint）| 中等 |

*关键关联*：
- 回流 一定会触发 重绘（布局变了，视觉必然要重新画）；
- 重绘 不会触发 回流（只是改颜色，位置 / 尺寸没变，无需重新计算布局）；
- 只有修改「合成层属性（transform/opacity）」时，既不回流也不重绘，仅触发合成（Composite），性能最优。

### 二、触发条件（精准识别哪些操作会导致回流 / 重绘）

1. *触发回流的高频操作（重点记）*
只要修改「元素几何信息」或「DOM 结构」，都会触发回流，常见场景：

- *DOM 结构变化*：增删 DOM 节点、移动节点位置（如 appendChild、insertBefore）；
- *尺寸变化*：修改 width/height、padding、margin、border-width、min-height 等；
- *位置变化*：修改 top/left/bottom/right、position（static→absolute）、float 等；
- *内容变化*：输入框输入文字、图片加载完成（尺寸变化）、文本换行（行数变化）；
- *浏览器行为*：窗口 resize、滚动页面（部分场景）、获取布局属性（见下文「坑点」）；
- *样式变化*：修改 display（none→block）、font-size（影响文本布局）、line-height 等。

2. *触发重绘的高频操作*
仅修改「视觉样式」且不影响几何属性，常见场景：
- 颜色类：color、background-color、border-color、outline-color；
- 视觉效果类：background-image、box-shadow、text-shadow、opacity（旧浏览器，现代浏览器 opacity 走合成）；
- 其他：visibility（hidden 仅重绘，none 触发回流）、cursor 等。

3. *既不回流也不重绘的操作（最优）*
仅修改「合成层属性」，直接在 GPU 层处理：
- transform（translate/scale/rotate/skew）；
- opacity（现代浏览器）；
- will-change（提前告知浏览器要优化的属性）。

### 三、性能影响：为什么要避免频繁回流 / 重绘？
1. *回流性能消耗高*：浏览器的布局计算是「流式的」—— 一个元素回流会触发其父节点、子节点、兄弟节点的连锁回流（比如修改一个 div 的 width，可能导致整个页面的布局重新计算）；
2. *重绘消耗中等*：虽然不用重新计算布局，但需要重新绘制像素，频繁触发仍会导致页面卡顿（比如每秒触发 60 次重绘，CPU 会被占满）；
3. *强制同步布局（最坑）*：如果在 JS 中「先读取布局属性，再修改样式」，浏览器会强制中断渲染队列，立即执行回流，导致性能暴跌。

*典型坑点示例（强制同步布局）：*
```js
// 反面例子：每循环一次都读取+修改，触发100次强制回流
const box = document.querySelector('.box');
for (let i = 0; i < 100; i++) {
  box.style.width = box.offsetWidth + 1 + 'px'; // 先读offsetWidth（触发回流），再改width（又触发）
}

// 正面例子：先批量读取，再批量修改，仅触发1次回流
const box = document.querySelector('.box');
let width = box.offsetWidth; // 先读一次，缓存值
for (let i = 0; i < 100; i++) {
  width += 1;
}
box.style.width = width + 'px'; // 最后统一修改，仅1次回流
```

### 四、可落地的优化方法（分维度，易执行）
*维度 1：减少触发次数（批量操作）*
核心思路：把多次回流 / 重绘的操作「合并成一次」。

1. 批量修改样式：
   - 不好的写法（触发多次回流）：
    ```js
    const box = document.querySelector('.box');
    box.style.width = '200px'; // 回流1
    box.style.height = '100px'; // 回流2
    box.style.backgroundColor = 'red'; // 重绘（因回流触发）
    ```
    - 好的写法（仅触发 1 次回流）：
    ```js
    // 方法1：通过class切换（推荐）
    box.classList.add('active'); // 一次修改多个样式

    // 方法2：先离线修改（DocumentFragment/克隆节点）
    const clone = box.cloneNode(true); // 克隆节点（离线，不影响DOM树）
    clone.style.width = '200px';
    clone.style.height = '100px';
    clone.style.backgroundColor = 'red';
    box.parentNode.replaceChild(clone, box); // 仅替换时触发1次回流
    ```

2. 避免频繁读取布局属性：
   - 缓存布局属性值（如 offsetTop、clientWidth、getBoundingClientRect 等），不要在循环中读取；
   - 若必须读取，先批量读取所有需要的值，再批量修改样式。

*维度 2：让元素「脱离文档流」再修改*
核心思路：脱离文档流的元素（absolute/fixed）修改时，不会触发其他元素的回流，仅自身回流。

```js
// 步骤1：让元素脱离文档流
box.style.position = 'absolute'; 
box.style.left = '0';
box.style.top = '0';

// 步骤2：批量修改样式（仅自身回流，不影响其他元素）
box.style.width = '300px';
box.style.height = '200px';

// 步骤3：恢复文档流（可选，根据业务需求）
box.style.position = 'static';
```

*维度 3：优先使用「合成层属性」实现动画*
核心思路：用 transform/opacity 替代 top/left/width 等属性做动画，避免回流。
- 反面例子（动画卡顿，每秒 60 次回流）：
```css
.animate {
position: relative;
animation: move 1s linear infinite;
}
@keyframes move {
0% { left: 0; }
100% { left: 100px; } // 修改left，触发回流
}
```
- 正面例子（动画流畅，仅触发合成）：
```css
.animate {
  animation: move 1s linear infinite;
}
@keyframes move {
  0% { transform: translateX(0); }
  100% { transform: translateX(100px); } // 仅触发合成
}
```

*维度 4：利用浏览器的「渲染队列」*
浏览器会把多次样式修改放入「渲染队列」，批量执行回流 / 重绘，*不要打断这个队列*：
- 错误：在修改样式后立即读取布局属性（触发强制同步布局）；
- 正确：要么先读所有属性再改样式，要么用 requestAnimationFrame 延迟读取。

*维度 5：其他实用技巧*
1. 隐藏元素修改：先设置 display: none，修改完样式后再恢复（仅触发 2 次回流，比直接修改少）；
2. 避免复杂选择器：CSS 选择器从右向左匹配，复杂选择器会增加样式计算时间，间接影响回流效率；
3. 启用硬件加速：用 will-change: transform 告知浏览器提前为元素创建合成层，优化动画性能；
4. 减少重绘区域：把频繁重绘的元素（如动画元素）单独放在一个图层，避免影响整个页面重绘。

### 五、「减少回流重绘技巧总结」

```markdown
# 前端性能优化：减少回流（Reflow）与重绘（Repaint）全攻略
## 一、核心概念
- 回流：修改元素几何属性（位置/尺寸），浏览器重新计算布局的过程，性能消耗极高；
- 重绘：修改元素视觉属性（颜色/背景），浏览器重新绘制像素的过程，性能消耗中等；
- 核心关联：回流必触发重绘，重绘不触发回流；transform/opacity 仅触发合成，无回流/重绘。

## 二、高频触发条件
### 1. 触发回流的操作
- DOM 增删/移动、修改尺寸（width/height/padding）、修改位置（top/left）；
- 窗口 resize、图片加载完成、读取布局属性（offsetTop/clientWidth）；
- 修改 display、font-size、line-height 等。

### 2. 触发重绘的操作
- 修改 color/background-color/box-shadow、visibility、cursor 等（不影响几何属性）。

## 三、核心优化技巧（按优先级排序）
### 1. 优先使用合成层属性（最优）
- 动画用 transform/opacity 替代 top/left/width；
- 用 will-change: transform 提前创建合成层，开启硬件加速。

### 2. 批量修改样式（减少触发次数）
- 推荐：通过 class 切换样式（一次修改多个属性）；
- 备选：克隆节点（DocumentFragment/.cloneNode）离线修改，再替换原节点；
- 避免：循环中逐个修改样式属性。

### 3. 避免强制同步布局
- 先批量读取所有布局属性（offsetTop/clientWidth 等），再批量修改样式；
- 用 requestAnimationFrame 延迟读取布局属性，不打断浏览器渲染队列。

### 4. 让元素脱离文档流修改
- 给元素设置 position: absolute/fixed，修改样式时仅自身回流，不影响其他元素；
- 临时隐藏元素：display: none → 修改样式 → 恢复 display，仅触发2次回流。

### 5. 其他实用技巧
- 减少复杂 CSS 选择器，降低样式计算时间；
- 动画元素单独分层，减少重绘区域；
- 避免频繁操作 DOM，尽量用虚拟列表渲染大量数据。

## 四、避坑案例
### 反面案例（强制同步布局，性能暴跌）
```js
const box = document.querySelector('.box');
for (let i = 0; i < 100; i++) {
  box.style.width = box.offsetWidth + 1 + 'px'; // 每次循环都触发回流
}
```

*正面案例（仅触发 1 次回流）*
```js
const box = document.querySelector('.box');
let width = box.offsetWidth; // 先缓存布局属性
for (let i = 0; i < 100; i++) {
  width += 1;
}
box.style.width = width + 'px'; // 最后统一修改
```