## 前端性能优化

一、*先建立全局认知：性能优化的 4 个核心阶段*

前端性能优化不是零散的技巧，而是覆盖「从用户输入 URL 到页面交互」的全流程，按以下 4 个阶段分类，逻辑最清晰，面试回答也最有条理：
*加载前优化（网络/服务端）* -> *加载中优化（资源加载）* -> *渲染中优化（浏览器渲染* -> *交互中优化（用户操作）* 

二、*分阶段拆解所有核心优化策略*

### *阶段 1：加载前优化（网络 / 服务端，基础中的基础）*
- 核心目标：减少请求耗时、降低请求数量

*1. 网络层优化*
- 核心原理：减少网络传输的耗时和开销
- 实战做法：
  1. *启用 HTTPS + HTTP/2/HTTP/3*：HTTP/2 支持多路复用、头部压缩、服务器推送，比 HTTP/1.1 快 30%+；HTTP/3 基于 QUIC 协议，解决 TCP 队头阻塞问题（面试必提）
  2. *使用 CDN 加速*：将静态资源（JS/CSS/ 图片）部署到就近的 CDN 节点，减少网络传输距离（比如阿里云 CDN、腾讯云 CDN）。
  3. *DNS 预解析*：提前解析域名，减少 DNS 解析耗时：
  ```html
  <link rel="dns-prefetch" href="https://cdn.example.com">
  ```
- *面试话术*：「首先优化网络层，启用 HTTP/2 多路复用减少连接开销，结合 CDN 就近分发静态资源，再通过 DNS 预解析提前解析域名，从源头降低请求耗时。」

*2. 服务端优化*
- 核心原理：减少服务端响应时间（TTFB）
- 实战做法：
  1. *服务端缓存*：用 Redis/Memcached 缓存接口数据、页面片段，避免重复查询数据库。
  2. *接口优化*：
     - 合并接口（减少请求数，比如把 3 个列表接口合并为 1 个）；
     - 分页加载（列表数据只返回当前页，避免一次性返回 1000 条）；
     - 压缩响应体（gzip/brotli，文本压缩率可达 70%+）。
  3. *SSR/SSG/ISR（按需选择）*：
     - SSR（服务端渲染）：首屏直出 HTML，优化 LCP/FCP（适合电商、资讯类站点）；
     - SSG（静态站点生成）：构建时生成静态 HTML，性能最优（适合博客、文档站）；
     - ISR（增量静态再生）：结合 SSG 和 SSR，兼顾性能和动态性。
- *面试话术*：「服务端层面，通过 Redis 缓存减少数据库压力，合并接口降低请求数，同时针对首屏优化场景选择 SSR，减少前端渲染耗时。」

### *阶段 2：加载中优化（资源加载，核心考点）*
- 核心目标：减少资源体积、按需加载资源

1. *代码分割（Code Splitting）*
- 核心原理：将打包后的大 JS/CSS 文件拆分成多个小文件，只加载当前页面需要的代码，减少首屏加载体积。
- 实战做法：
  1. *Webpack/Vite 基础分割：*
     - Webpack：配置 splitChunks 拆分第三方库（如 React/Vue）和公共代码：
     ```js
        // webpack.config.js
        module.exports = {
        optimization: {
            splitChunks: {
            chunks: 'all', // 拆分同步/异步代码
            cacheGroups: {
                vendor: { // 拆分第三方库
                test: /[\\/]node_modules[\\/]/,
                name: 'vendors',
                chunks: 'all'
                }
            }
            }
        }
        }
     ```
     - Vite：默认拆分 vendor，无需额外配置，可通过 build.rollupOptions 自定义。
   2. *动态导入（Dynamic Import）：手动拆分非首屏代码：*
      ```js
        // 点击按钮后再加载防抖函数
        const handleClick = async () => {
        const { debounce } = await import('lodash-es');
        const debouncedFn = debounce(() => console.log('点击'), 300);
        debouncedFn();
        };
      ```
- 面试话术：「代码分割是前端性能优化的核心，我会通过 Webpack 的 splitChunks 拆分第三方库和公共代码，再结合动态导入拆分非首屏逻辑，比如点击按钮才加载的功能模块，大幅减少首屏 JS 体积。」

2. *路由懒加载（路由层面的代码分割）*
- 核心原理：只加载当前路由对应的组件代码，而非一次性加载所有路由组件（Vue/React 通用）。
- 实战做法：
  1. Vue 路由懒加载：
     ```js
        // router/index.js
        import { createRouter, createWebHistory } from 'vue-router';
        // 懒加载 Home/About 组件
        const Home = () => import('../views/Home.vue');
        const About = () => import(/* webpackChunkName: "about" */ '../views/About.vue');

        const routes = [
        { path: '/', component: Home },
        { path: '/about', component: About }
        ];
     ```
   2. React 路由懒加载：
      ```js
        // App.js
        import { lazy, Suspense } from 'react';
        import { BrowserRouter, Routes, Route } from 'react-router-dom';
        // 懒加载组件
        const Home = lazy(() => import('./views/Home'));
        const About = lazy(() => import('./views/About'));

        function App() {
        return (
            <BrowserRouter>
            <Suspense fallback={<div>加载中...</div>}>
                <Routes>
                <Route path="/" element={<Home />} />
                <Route path="/about" element={<About />} />
                </Routes>
            </Suspense>
            </BrowserRouter>
        );
        }
      ```

- 面试话术：「路由懒加载是代码分割的典型应用，我在 Vue 项目中通过 import () 动态导入路由组件，React 中结合 lazy + Suspense 实现，让每个路由只加载自己的代码，首屏加载体积减少 60%+。」


3. *资源缓存（避免重复加载）*
- 核心原理：利用浏览器缓存机制，让资源只加载一次，后续请求直接从本地读取。
- 实战做法（按优先级排序）：
  1. *强缓存（优先级最高）：*
     - 服务端设置响应头：Cache-Control: max-age=31536000（缓存 1 年）、Expires: Thu, 31 Dec 2026 23:59:59 GMT；
     - 适用场景：不常变的静态资源（如第三方库、图片、字体）。
  2. *协商缓存：*
     - 服务端设置响应头：ETag/Last-Modified，客户端请求时携带 If-None-Match/If-Modified-Since，服务端判断资源是否变化，未变化返回 304；
     - 适用场景：偶尔更新的资源（如业务 JS/CSS）。
  3. *本地存储缓存：*
     - 用 localStorage 缓存非敏感的静态数据（如城市列表、字典数据）；
     - 用 sessionStorage 缓存会话级数据（如表单临时数据）。
  4. *Service Worker 缓存（PWA）：*
      - 离线缓存资源，支持离线访问（适合移动端应用）。

- 面试话术：「缓存策略我会分层次使用：强缓存缓存第三方库等静态资源，协商缓存处理业务代码，本地存储缓存字典类数据，核心是让资源『一次加载，多次复用』，减少重复请求。」

4. *图片优化（前端性能优化的重中之重）*
- 核心原理：减少图片体积、按需加载图片、降低渲染开销。
- 实战做法（面试必背，按优先级排序）：
  1. 选择最优格式：
     - 静态图片：WebP/AVIF（体积比 JPG 小 30%~50%）；
     - 动图：WebP（替代 GIF，体积更小）、Lottie（矢量动图，体积极小）；
     - 图标：SVG（矢量，无限缩放）、Iconfont（字体图标，复用性高）。
  2. 压缩图片：
     - 工具：TinyPNG、Squoosh（在线压缩）、webpack-image-loader（构建时压缩）；
     - 目标：保证清晰度的前提下，体积减少 50%+。
  3. 按需加载：
     - 懒加载：`<img src="xxx.jpg" loading="lazy">`（原生懒加载），或用 IntersectionObserver 实现自定义懒加载；
     - 响应式图片：用 srcset + sizes 适配不同设备：
       ```html
            <img 
            src="image-400w.jpg" 
            srcset="image-400w.jpg 400w, image-800w.jpg 800w" 
            sizes="(max-width: 600px) 400px, 800px"
            >
       ```
   4. 减少渲染开销
      - 提前指定宽高：`<img src="xxx.jpg" width="400" height="300">` 或 aspect-ratio: 4/3，避免 CLS；
      - 预加载首屏图片：`<link rel="preload" as="image" href="hero.jpg">`。

- 面试话术：「图片优化是我重点关注的方向，首先替换为 WebP 格式减少体积，结合原生懒加载避免首屏加载所有图片，用 srcset 适配不同设备，同时指定宽高避免布局偏移，整体能让图片相关的加载耗时减少 50%。」

### 阶段 3：渲染中优化（浏览器渲染，减少回流 / 重绘）

核心目标：减少渲染耗时、避免不必要的回流 / 重绘

1. *首屏优化（核心中的核心）*
- 核心原理：让首屏内容尽快显示，优化 LCP/FCP/CLS。
- 实战做法（面试必背，按优先级排序）:
  1. *内联关键 CSS*：只把首屏需要的 CSS 内联到 HTML 中，非首屏 CSS 异步加载：
     ```html
        <style>
        /* 仅首屏必需的样式 */
        .header { height: 80px; }
        .hero { width: 100%; }
        </style>
        <link rel="stylesheet" href="non-critical.css" media="print" onload="this.media='all'">
     ```
  2. *异步加载非首屏 JS*：首屏不需要的 JS 用 async/defer 加载，或放到  `</body>` 底部。
  3. *骨架屏（Skeleton）*：首屏加载时显示骨架屏，替代白屏，提升用户感知：
  4. *预加载关键资源*：预加载首屏图片、字体：
     ```html
        <link rel="preload" as="image" href="hero.jpg">
        <link rel="preload" as="font" href="iconfont.woff2" crossorigin>
     ```
  5. *减少首屏 DOM 节点*：首屏只渲染必要的 DOM，非首屏内容（如底部 /footer）延迟渲染。

- 面试话术：「首屏优化我会从『感知 + 实际』双维度入手：内联关键 CSS 让首屏样式尽快渲染，用骨架屏提升用户感知，异步加载非首屏 JS 减少阻塞，同时预加载首屏主图，最终让 LCP 控制在 2.5s 以内。」

2. * 渲染优化（减少回流 / 重绘）*

- *核心原理*：避免频繁触发回流 / 重绘，优先使用合成层属性。
- 实战做法：
  1. *批量修改样式*：通过 class 切换样式，而非逐个修改：
      ```js
        // 好的写法
        element.classList.add('active');
        // 不好的写法
        element.style.width = '200px';
        element.style.height = '100px';
      ```
  2. 脱离文档流修改元素：用 position: absolute/fixed 让元素脱离文档流，修改时不影响其他元素。
  3. 优先使用合成层属性：动画用 transform/opacity，避免 top/left/width，并结合 will-change: transform 提前优化。
  4. 避免强制同步布局：先批量读取布局属性（如 offsetTop），再批量修改样式。

- 面试话术：「渲染阶段我会重点避免回流 / 重绘，批量修改样式减少触发次数，用 transform 做动画避免回流，同时避免强制同步布局，让主线程更流畅。」

### 阶段 4：交互中优化（用户操作，优化 FID/INP/TBT）
核心目标：*减少主线程阻塞，提升交互响应速度*
1. *优化 JS 执行*
- 核心原理：减少主线程耗时，避免长任务阻塞。
- 实战做法：
    - *拆分长任务*：把执行时间 >50ms 的长任务拆成短任务，用 requestIdleCallback/setTimeout 执行：
    ```js
        // 拆分长循环
        const processData = async (data) => {
        const chunkSize = 100;
        for (let i = 0; i < data.length; i += chunkSize) {
            await new Promise(resolve => setTimeout(resolve, 0));
            const chunk = data.slice(i, i + chunkSize);
            // 处理当前分片
        }
        };
    ```
    - *Web Worker 处理复杂计算*：把数据处理、图表渲染等复杂逻辑放到 Web Worker，不阻塞主线程：
    ```js
        // main.js
        const worker = new Worker('worker.js');
        worker.postMessage({ data: largeData });
        worker.onmessage = (e) => {
        console.log('计算结果：', e.data);
        };

        // worker.js
        self.onmessage = (e) => {
        const result = e.data.data.map(item => item * 2); // 复杂计算
        self.postMessage(result);
        };
    ```
    - *防抖 / 节流高频事件*：对 scroll/resize/input 等高频事件做防抖 / 节流：
    ```js
        // 防抖
        const debounce = (fn, delay) => {
        let timer = null;
        return (...args) => {
            clearTimeout(timer);
            timer = setTimeout(() => fn.apply(this, args), delay);
        };
        };
        window.addEventListener('resize', debounce(handleResize, 300));
    ```

- 面试话术：「交互优化的核心是释放主线程，我会把复杂计算放到 Web Worker，拆分长任务避免阻塞，对高频事件做防抖节流，最终让 INP 控制在 200ms 以内，保证交互流畅。」


## 阶段优化总结
#### 一、加载前优化（网络/服务端）
| 优化方向 | 核心做法 | 优化目标 |
|----------|----------|----------|
| 网络层 | 1. 启用 HTTP/2/HTTP/3<br>2. 部署 CDN<br>3. DNS 预解析 | 减少网络传输耗时 |
| 服务端 | 1. 服务端缓存（Redis）<br>2. 接口合并/分页<br>3. 响应体压缩（gzip/brotli）<br>4. 按需选择 SSR/SSG/ISR | 降低 TTFB（<600ms） |

#### 二、加载中优化（资源加载）
| 优化方向 | 核心做法 | 优化目标 |
|----------|----------|----------|
| 代码分割 | 1. Webpack/Vite 拆分第三方库<br>2. 动态导入非首屏代码 | 减少首屏 JS 体积 |
| 路由懒加载 | Vue：import() 动态导入<br>React：lazy + Suspense | 按需加载路由代码 |
| 资源缓存 | 1. 强缓存（Cache-Control）<br>2. 协商缓存（ETag/Last-Modified）<br>3. 本地存储缓存静态数据 | 避免重复加载资源 |
| 图片优化 | 1. 格式：WebP/AVIF/SVG<br>2. 压缩：TinyPNG/loader 压缩<br>3. 懒加载：loading="lazy"<br>4. 响应式：srcset + sizes<br>5. 预加载首屏图片 | 减少图片体积，优化 LCP/CLS |

#### 三、渲染中优化（浏览器渲染）
| 优化方向 | 核心做法 | 优化目标 |
|----------|----------|----------|
| 首屏优化 | 1. 内联关键 CSS<br>2. 异步加载非首屏 JS<br>3. 骨架屏提升感知<br>4. 预加载关键资源<br>5. 减少首屏 DOM 节点 | 优化 LCP/FCP/CLS（LCP≤2.5s） |
| 渲染优化 | 1. 批量修改样式（class 切换）<br>2. 脱离文档流修改元素<br>3. 动画用 transform/opacity<br>4. 避免强制同步布局 | 减少回流/重绘，优化 TBT |

#### 四、交互中优化（用户操作）
| 优化方向 | 核心做法 | 优化目标 |
|----------|----------|----------|
| JS 执行优化 | 1. 拆分长任务（requestIdleCallback）<br>2. Web Worker 处理复杂计算<br>3. 防抖/节流高频事件 | 优化 FID/INP（INP≤200ms） |
| 事件优化 | 1. 事件委托（减少事件绑定）<br>2. 及时移除无用事件监听 | 减少主线程开销 |

#### 五、面试高频总结
1. 性能优化核心：「减少体积、减少请求、减少阻塞、提升感知」；
2. 核心指标优化：LCP（首屏资源）、INP（主线程）、CLS（布局稳定）；
3. 优化优先级：网络层 > 资源加载 > 渲染 > 交互（从源头到细节）。