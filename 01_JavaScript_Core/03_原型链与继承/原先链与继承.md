# 原型链与继承学习笔记
## 一、原型链核心概念
1. 原型（prototype）：函数特有的属性，指向原型对象，用于存放共享方法/属性。
2. 原型链：实例`__proto__`指向构造函数的`prototype`，层层向上直到`null`，构成原型链，是继承的底层基础。
3. constructor：原型对象的属性，指向关联的构造函数，继承时需手动修正，否则指向错误。

## 二、ES5六种继承方式
### 1. 原型链继承
- 实现：`Child.prototype = new Parent()`
- 优点：简单，可继承父类原型方法
- 缺点：引用类型属性共享、无法传参
```js
function Parent(name, age){
    this.name = name
    this.age = age
}

function Child(){}

Child.prototype = new Parent('xx', 'yy')
Child.prototype.constructor = Child

const c1 = new Child()

console.log(c1.name, c1.age)
```

### 2. 借用构造函数继承
- 实现：子类构造函数中`Parent.call(this, 参数)`
- 优点：支持传参、解决引用类型共享
- 缺点：无法继承原型方法、方法复用性差
```js
function Parent2(name, age){
    this.name = name
    this.age = age
}

Parent2.prototype.log = () => {
    console.log('父类原型方法--------')
}

function Child2(sex, ...args){
    this.sex = sex
    Parent2.call(this, ...args)
}

const c2 = new Child2('女', '刘亦菲', '22')
console.log(c2.sex, c2.name, c2.age) // 女 刘亦菲 22
c2.log() // c2.log is not a function
```

### 3. 组合继承
- 实现：原型链+借用构造函数
- 优点：兼顾传参、原型方法继承
- 缺点：父类构造函数调用两次，存在冗余属性
```js
function Parent3(name, age){
    this.name = name
    this.age = age
}

Parent3.prototype.log = () => {
    console.log('我是刘德华--------')
}

function Child3(sex, ...args){
    this.sex = sex
    Parent3.call(this, ...args)
}

Child3.prototype = new Parent3()

const c3 = new Child3('男', '刘德华', '18')
c3.log() // 我是刘德华--------
```

### 4. 原型式继承
- 实现：`Object.create(父对象)`（或自定义空函数中介）
- 优点：基于现有对象创建新对象，浅拷贝
- 缺点：引用类型共享，无构造函数复用
```js
function createObj(obj) {
  function F(){}
  F.prototype = obj
  return new F()
}

const parent = {
  name: '张学友',
  friends: ['小明', '小张']
};

const childObj = createObj(parent)

console.log(childObj.name) // 张学友
childObj.friends.push('周润发')
console.log(parent.friends) // [ '小明', '小张', '周润发' ]
```

### 5. 寄生式继承
- 实现：原型式继承+增强对象（添加方法）
- 优点：可自定义实例方法
- 缺点：方法无法复用，每次创建新函数
```js
function createChild(parent){
    const child = Object.create(parent)
    child.log = () => {
        console.log('寄生式继承-------')
    }
    return child
}

const parent2 = {
  name: '张学友',
  friends: ['小明', '小张']
};

const child5 = createChild(parent2)
const child6 = createChild(parent2)
child5.log() // 寄生式继承-------
console.log(child5.log === child6.log) // false
```

### 6. 寄生组合式继承
- 实现：借用构造函数+寄生继承父类原型（不调用父类构造）
- 优点：ES5最优方案，仅调用一次父类构造，无冗余属性
- 缺点：代码稍复杂，需封装继承原型的函数
```js
function Parent6(name, age){
    this.name = name
    this.age = age
}

Parent6.prototype.log = () => {
    console.log('寄生组合式继承--------')
}

function Child6(sex, ...args){
    this.sex = sex
    Parent6.call(this, ...args)
}

const proxyObj = Object.create(Parent6.prototype)
Child6.prototype = proxyObj
proxyObj.constructor = Child6

const c6 = new Child6('男', '刘德华', '18')
c6.log() // 寄生组合式继承--------
console.log(c6.__proto__.__proto__ === Parent6.prototype) // true
console.log(c6.constructor === Child6) // true
```

## 三、ES6继承
ES6退出语法糖Class实现继承，替代ES5继承方式，代码简介可读性更强
```js
class Parent7 {
    constructor(name, age){
        this.name = name
        this.age = age
    }
    log(){
        console.log('父类方法-----------')
    }
    static hello(){
        console.log('父类static----------')
    }
}

class Child7 extends Parent7 {
    constructor(sex, ...args){
        super(...args)
        this.sex = sex
    }
    log(){
        super.log()
        console.log('子类方法------------')
    }
    static hello(){
        console.log('子类static----------')
        super.hello()
    }
}

const c7 = new Child7('男', '周星驰', 18)
console.log(c7) // Child7 { name: '周星驰', age: 18, sex: '男' }
c7.log() // 父类方法----------- 子类方法------------
Child7.hello() // 子类static---------- 父类static----------
``

## 四、ES5 vs ES6 继承差异
1. 实现方式：ES5手动操作原型链+构造函数；ES6用`class/extends`语法糖（底层仍为原型链）。
2. 构造函数调用：ES5手动调用`Parent.call(this)`；ES6必须通过`super()`调用（且为子类构造第一行）。
3. 静态方法继承：ES5需手动赋值；ES6`extends`自动继承。
4. 可读性：ES5代码分散，需理解原型链；ES6语义化强，接近传统OOP。