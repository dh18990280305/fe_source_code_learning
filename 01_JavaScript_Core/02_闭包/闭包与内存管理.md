## 1. 闭包核心原理
1.1 闭包定义
是指函数能够访问并保留其词法作用域（定义时的作用域）中的变量，即使该函数在其词法作用域之外执行。
- 本质：函数 + 其词法环境的组合
- 核心：函数可以记住并访问其定义时的作用域，即使在其他作用域执行

1.2 闭包形成条件（缺一不可） 
- 函数嵌套：内部函数定义在外部函数内部
- 内部函数引用外部函数的变量 / 参数
- 外部函数执行，内部函数被返回或传递到外部作用域执行

1.3 闭包工作原理（底层逻辑）
- JS 采用词法作用域（静态作用域）：函数的作用域在定义时确定，而非执行时
- 当外部函数执行时，会创建执行上下文和词法环境（存储变量 / 函数）
- 若内部函数引用了外部函数的变量，外部函数执行完毕后，其词法环境不会被垃圾回收，而是被内部函数保留，形成闭包
- 内部函数执行时，会先查找自身作用域，再逐级向上查找闭包中的词法环境

1.4 闭包的优缺点
| 优点      | 缺点 |
| ----------- | ----------- |
| 1.私有化变量，避免全局污染      | 1.使用不当，可能造成内存泄漏 |
| 2.实现模块化，封装私有方法，属性   | 2.过度使用增加内存暂用，影响性能 |
| 3.保存函数执行状态，如防抖，节流 | 3.调试困难，闭包变量无法在全局作用域访问 |

## 2. 闭包与内存管理
2.1 闭包导致内存泄漏原因
- 闭包会**保留外部作用域的词法环境**，即使外部函数执行完成，词法环境仍然被内部函数引用
- 若内部函数长期存在（如全局变量、事件监听、定时器），闭包中的变量会一直占用内存，无法被垃圾回收，导致内存泄漏

``` js
// 内存泄漏：定时器长期引用闭包变量，无法被回收
function leakExample() {
  const largeData = new Array(1000000).fill('内存泄漏数据'); // 大数组
  setInterval(() => {
    console.log(largeData.length); // 定时器引用闭包变量
  }, 1000);
}
leakExample(); // 执行后，largeData 永远无法被回收
```
2.2 闭包导致内存泄漏解决方案
- 及时解除引用：不再使用闭包时，将引用设置为 null
```js
function fixLeak() {
  let largeData = new Array(1000000).fill('修复后数据');
  const timer = setInterval(() => {
    console.log(largeData.length);
  }, 1000);
  // 5秒后清除定时器并解除引用
  setTimeout(() => {
    clearInterval(timer);
    largeData = null; // 解除引用，允许垃圾回收
  }, 5000);
}
fixLeak();
```
- 避免不必要的闭包：仅在需要时使用闭包，减少长期存在的闭包引用
- 使用弱引用（ES6+）：通过 WeakMap/WeakSet 存储闭包变量，垃圾回收可自动回收
```js
function weakRefExample() {
  const weakData = new WeakMap();
  const obj = { data: new Array(1000000).fill('弱引用数据') };
  weakData.set(obj, obj.data);
  // 当 obj 无其他引用时，WeakMap 中的数据会被自动回收
}
weakRefExample();
```

## 3. 闭包使用场景

场景1：实现模块化封装
```js
const counterModule = (function (){
    // 私有化变量
    let counter = 0
    // 全局作用域无法方法，只能通过对外暴露方法操作和获取
    return {
        log(){
            console.log(counter)
        },
        increment(){
            counter++
            this.log()
        },
        getCount(){
            return counter
        }
    }
}())
counterModule.log()
counterModule.increment()
counterModule.increment()
```

场景2：实现防抖
```js
// 防抖函数
const debounce = (fn, delay, immediate = false) => {
    let timer = null
    return function (...args){
        const firstCall = immediate && !timer
        if(timer) clearTimeout(timer)
        timer = setTimeout(() => {
            fn.apply(this, args)
            timer = null
        }, delay)
        if(firstCall){
            fn.apply(this, args)
        }
    }
}

const handleClick = debounce((...args) => {
    console.log('被点击了-------', args)
}, 1000, true)

handleClick(1,2,3)
```

场景3：节流实现
```js
// 节流函数
function throttle(fn, delay, params = { leading: false, trailing: false }){
    let lastTime = 0;
    let timer = null
    const { leading, trailing } = params
    function exec(context, args){
        fn.call(context, ...args)
        lastTime = Date.now()
    }
    return function(...args){
        const currentTime = Date.now()
        const context = this
        if(lastTime === 0){
            if(leading){
                exec(context, args)
                return
            }
            lastTime = currentTime
        }
        // 剩余时间
        const remaining  = delay - (currentTime - lastTime) 
        if(remaining <= 0){
            if(timer){
                clearTimeout(timer)
                timer = null
            }
            exec(context, args)
        }
        // 开启trailing && 只设置一个setTimeout
        else if(trailing && !timer){
            timer = setTimeout(() => {
                exec(context, args)
                timer = null
                lastTime = Date.now();
            }, remaining)
        }
    }
}


const handleClick2 = throttle((...args) => {
    console.log('节流测试---------', args)
}, 1000, { leading: true, trailing: true })

window.addEventListener('scroll', () => {
    handleClick2()
})
``````

场景4：私有变量（闭包保护对象属性）
```js
// 私有函数
function createUser(name, password) {
  // 私有变量
  const _password = password;

  // 对外暴露
  return {
    name: name,
    verifyPassword: function(inputPwd) {
      return inputPwd === _password;
    }
  };
}

const user = createUser('张三', '123456');
console.log(user.name); // 张三
console.log(user._password); // undefined（私有变量）
```

## 4. 闭包在 React Hooks 中的应用
4.1 Hooks 中的闭包形成原因
- React 函数组件每次渲染都会重新执行，生成新的函数实例（如 useEffect 回调、useCallback 函数）
- 这些函数会捕获当前渲染周期的props/state，形成闭包，即使组件重新渲染，旧的闭包仍保留旧的状态值

4.2 常见闭包陷阱
1. useEffect 闭包捕获旧 state
```js
import { useState, useEffect } from 'react';

function ClosureTrap() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // 闭包捕获初始 count=0，即使 count 变化，定时器仍使用旧值
    const timer = setInterval(() => {
      console.log('count:', count); // 永远输出 0
    }, 1000);
    return () => clearInterval(timer);
  }, []); // 依赖数组为空，仅挂载时执行一次

  return (
    <div>
      <p>count: {count}</p>
      <button onClick={() => setCount(prev => prev + 1)}>增加</button>
    </div>
  );
}
```
2. useCallback 闭包捕获旧 props/state
```js
import { useState, useCallback } from 'react';

function CallbackClosure() {
  const [count, setCount] = useState(0);

  // useCallback 捕获初始 count=0，依赖数组为空，不会更新
  const handleClick = useCallback(() => {
    console.log('count:', count); // 永远输出 0
  }, []);

  return (
    <div>
      <p>count: {count}</p>
      <button onClick={() => setCount(prev => prev + 1)}>增加</button>
      <button onClick={handleClick}>打印 count</button>
    </div>
  );
}
```
4.3 hooks闭包问题解决方案
1. 完善依赖数组：将 useEffect/useCallback 中使用的变量加入依赖数组，确保闭包更新
```js
// 修复 useEffect 闭包
useEffect(() => {
  const timer = setInterval(() => {
    console.log('count:', count); // 每次 count 变化，闭包更新
  }, 1000);
  return () => clearInterval(timer);
}, [count]); // 加入 count 依赖
```

2. 使用 useRef 保存最新值：useRef 保存的变量不触发重渲染，可获取最新值
```js
// 修复 useCallback 闭包
const [count, setCount] = useState(0);
const countRef = useRef(count);

// 每次 count 变化，更新 ref
useEffect(() => {
  countRef.current = count;
}, [count]);

// useCallback 无需依赖 count，通过 ref 获取最新值
const handleClick = useCallback(() => {
  console.log('count:', countRef.current); // 获取最新 count
}, []);
```